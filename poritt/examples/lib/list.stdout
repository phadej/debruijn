define ListC : U = {:cons :nil}
defined ListC : U = {:cons :nil}

define ListF
  : U -> ListC -> Desc
  = \ A c -> switch c (\ _ -> Desc) {:cons -> `S A (\ _ -> `X `1); :nil -> `1}
defined ListF
  : U -> ListC -> Desc
  = \ A c -> switch c (\ _ -> Desc) {:cons -> `S A (\ _ -> `X `1); :nil -> `1}

define ListD : U -> Desc = \ A -> `S ListC (ListF A)
defined ListD : U -> Desc = \ A -> `S ListC (ListF A)

define List : U -> U = \ A -> mu (ListD A)
defined List : U -> U = \ A -> mu (ListD A)

define nil : forall (A : U) -> List A = \ _ -> :nil
defined nil : forall (A : U) -> List A = \ _ -> con (:nil , :tt)

define cons : forall (A : U) -> A -> List A -> List A = \ _ x xs -> :cons x xs
defined cons
  : forall (A : U) -> A -> List A -> List A
  = \ _ x xs -> con (:cons , x , xs , :tt)

macro %nil = con (:nil , :tt)
macro %nil 
  = con (:nil , :tt)

macro %cons = con (:cons , x , xs , :tt)
macro %cons x xs
  = con (:cons , x , xs , :tt)

include "sigma.ptt"

define sig : forall (A : U) (B : A -> U) -> U = \ A B -> exists (x : A) * B x
defined sig : forall (A : U) -> (A -> U) -> U = \ A B -> exists (x : A) * B x

define indSig
  : forall
      (A : U)
      (B : A -> U)
      (e : sig A B)
      (M : sig A B -> U)
      (m : forall (x : A) (y : B x) -> M (x , y)) ->
      M e
  = \ A B e M m -> m (e .fst) (e .snd)
defined indSig
  : forall
      (A : U) (B : A -> U) (e : sig A B) (M : sig A B -> U) ->
      (forall (x : A) (y : B x) -> M (x , y)) -> M e
  = \ A B e M m -> m (e .fst) (e .snd)

end-of-file "examples/lib/sigma.ptt"

define foldr
  : forall (A : U) (B : U) -> (A -> B -> B) -> B -> List A -> B
  = \ A B consC nilC e ->
      ind
        e
        (\ _ -> B)
        (\ d ->
           indSig
             ListC
             (\ c -> evalDesc (ListF A c) (List A))
             d
             (\ d' -> All (ListD A) (mu (ListD A)) (\ _ -> B) d' -> B)
             (\ c ->
                switch c (\ c' ->
                            forall
                              (y : evalDesc (ListF A c') (List A)) ->
                              All
                                (ListD A)
                                (mu (ListD A))
                                (\ _ -> B)
                                (c' , y) ->
                              B)
                  {:cons -> \ x acc -> consC (x .fst) (acc .fst);
                  :nil -> \ _ _ -> nilC}))
defined foldr
  : forall (A : U) (B : U) -> (A -> B -> B) -> B -> List A -> B
  = \ A B consC nilC e ->
      ind
        e
        (\ _ -> B)
        (\ d ->
           indSig
             ListC
             (\ c -> evalDesc (ListF A c) (List A))
             d
             (\ d' -> All (ListD A) (mu (ListD A)) (\ _ -> B) d' -> B)
             (\ c ->
                switch c (\ c' ->
                            forall
                              (y : evalDesc (ListF A c') (List A)) ->
                              All
                                (ListD A)
                                (mu (ListD A))
                                (\ _ -> B)
                                (c' , y) ->
                              B)
                  {:cons -> \ x acc -> consC (x .fst) (acc .fst);
                  :nil -> \ _ _ -> nilC}))

define indList
  : forall
      (A : U)
      (e : List A)
      (M : List A -> U)
      (Mnil : M (nil A))
      (Mcons : forall (x : A) (xs : List A) -> M xs -> M (cons A x xs)) ->
      M e
  = \ A e M Mnil Mcons ->
      ind
        e
        M
        (\ d ->
           indSig
             ListC
             (\ c -> evalDesc (ListF A c) (List A))
             d
             (\ d' -> All (ListD A) (mu (ListD A)) M d' -> M (con d'))
             (\ c ->
                switch c (\ c' ->
                            forall
                              (y : evalDesc (ListF A c') (List A)) ->
                              All (ListD A) (mu (ListD A)) M (c' , y) ->
                              M (con (c' , y)))
                  {:cons -> \ e' allE ->
                              Mcons (e' .fst) (e' .snd .fst) (allE .fst);
                  :nil -> \ e' allE -> Mnil}))
defined indList
  : forall
      (A : U) (e : List A) (M : List A -> U) ->
      M (nil A) ->
      (forall (x : A) (xs : List A) -> M xs -> M (cons A x xs)) -> M e
  = \ A e M Mnil Mcons ->
      ind
        e
        M
        (\ d ->
           indSig
             ListC
             (\ c -> evalDesc (ListF A c) (List A))
             d
             (\ d' -> All (ListD A) (mu (ListD A)) M d' -> M (con d'))
             (\ c ->
                switch c (\ c' ->
                            forall
                              (y : evalDesc (ListF A c') (List A)) ->
                              All (ListD A) (mu (ListD A)) M (c' , y) ->
                              M (con (c' , y)))
                  {:cons -> \ e' allE ->
                              Mcons (e' .fst) (e' .snd .fst) (allE .fst);
                  :nil -> \ e' allE -> Mnil}))

end-of-file "examples/lib/list.ptt"

