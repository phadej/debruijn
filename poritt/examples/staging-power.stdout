include "lib/nat.ptt"

define NatC : U = {:succ :zero}
defined NatC : U = {:succ :zero}

define NatF
  : NatC -> Desc
  = \ c -> switch c (\ _ -> Desc) {:succ -> `X `1; :zero -> `1}
defined NatF
  : NatC -> Desc
  = \ c -> switch c (\ _ -> Desc) {:succ -> `X `1; :zero -> `1}

define NatD : Desc = `S NatC NatF
defined NatD : Desc = `S NatC NatF

define Nat : U = mu NatD
defined Nat : U = mu NatD

eval Nat
  = mu (`S {:succ :zero} (\ c ->
                            switch c (\ _ -> Desc)
                              {:succ -> `X `1; :zero -> `1}))
  : U

define zero : Nat = :zero
defined zero : Nat = con (:zero , :tt)

define succ : Nat -> Nat = \ n -> :succ n
defined succ : Nat -> Nat = \ n -> con (:succ , n , :tt)

define one = succ zero
defined one : Nat = succ zero

define two = succ one
defined two : Nat = succ one

define three = succ two
defined three : Nat = succ two

define four = succ three
defined four : Nat = succ three

define five = succ four
defined five : Nat = succ four

include "sigma.ptt"

define sig : forall (A : U) (B : A -> U) -> U = \ A B -> exists (x : A) * B x
defined sig : forall (A : U) -> (A -> U) -> U = \ A B -> exists (x : A) * B x

define indSig
  : forall
      (A : U)
      (B : A -> U)
      (e : sig A B)
      (M : sig A B -> U)
      (m : forall (x : A) (y : B x) -> M (x , y)) ->
      M e
  = \ A B e M m -> m (e .fst) (e .snd)
defined indSig
  : forall
      (A : U) (B : A -> U) (e : sig A B) (M : sig A B -> U) ->
      (forall (x : A) (y : B x) -> M (x , y)) -> M e
  = \ A B e M m -> m (e .fst) (e .snd)

end-of-file "examples/lib/sigma.ptt"

define indNat
  : forall
      (M : Nat -> U)
      (Mzero : M zero)
      (Msucc : forall (n : Nat) -> M n -> M (succ n))
      (e : Nat) ->
      M e
  = \ M Mzero Msucc e ->
      ind
        e
        M
        (\ d ->
           indSig
             NatC
             (\ c -> evalDesc (NatF c) Nat)
             d
             (\ d' -> All (NatF (d' .fst)) Nat M (d' .snd) -> M (con d'))
             (\ c ->
                switch c (\ c' ->
                            forall
                              (y : evalDesc (NatF c') Nat) ->
                              All (NatF c') Nat M y -> M (con (c' , y)))
                  {:succ -> \ n Mn -> Msucc (n .fst) (Mn .fst);
                  :zero -> \ _ _ -> Mzero}))
defined indNat
  : forall
      (M : Nat -> U) ->
      M zero ->
      (forall (n : Nat) -> M n -> M (succ n)) -> forall (e : Nat) -> M e
  = \ M Mzero Msucc e ->
      ind
        e
        M
        (\ d ->
           indSig
             NatC
             (\ c -> evalDesc (NatF c) Nat)
             d
             (\ d' -> All (NatF (d' .fst)) Nat M (d' .snd) -> M (con d'))
             (\ c ->
                switch c (\ c' ->
                            forall
                              (y : evalDesc (NatF c') Nat) ->
                              All (NatF c') Nat M y -> M (con (c' , y)))
                  {:succ -> \ n Mn -> Msucc (n .fst) (Mn .fst);
                  :zero -> \ _ _ -> Mzero}))

define iterNat
  : forall (A : U) -> A -> (A -> A) -> Nat -> A
  = \ A z s n -> indNat (\ _ -> A) z (\ _ n -> s n) n
defined iterNat
  : forall (A : U) -> A -> (A -> A) -> Nat -> A
  = \ A z s n -> indNat (\ _ -> A) z (\ _ n0 -> s n0) n

define plus : Nat -> Nat -> Nat = \ n m -> iterNat Nat m succ n
defined plus : Nat -> Nat -> Nat = \ n m -> iterNat Nat m succ n

define mult : Nat -> Nat -> Nat = \ n m -> iterNat Nat zero (plus m) n
defined mult : Nat -> Nat -> Nat = \ n m -> iterNat Nat zero (plus m) n

end-of-file "examples/lib/nat.ptt"

define power
  : Nat -> Nat -> Nat
  = \ n m -> iterNat Nat (succ zero) (\ acc -> mult m acc) n
defined power
  : Nat -> Nat -> Nat
  = \ n m -> iterNat Nat (succ zero) (\ acc -> mult m acc) n

define power5 = power five
defined power5 : Nat -> Nat = power five

define powerCode
  : Nat -> Code Nat -> Code Nat
  = \ n m -> iterNat (Code Nat) [| succ zero |] (\ acc -> [| mult $m $acc |]) n
defined powerCode
  : Nat -> Code Nat -> Code Nat
  = \ n m -> iterNat (Code Nat) [| succ zero |] (\ acc -> [| mult $m $acc |]) n

define power5' : Nat -> Nat = \ p -> $(powerCode five [| p |])
defined power5'
  : Nat -> Nat
  = \ p -> mult p (mult p (mult p (mult p (mult p (succ zero)))))

include "lib/leibniz.ptt"

define Id
  : forall (A : U) (x : A) (y : A) -> U
  = \ A x y -> forall (C : A -> U) -> C x -> C y
defined Id
  : forall (A : U) -> A -> A -> U
  = \ A x y -> forall (C : A -> U) -> C x -> C y

define refl : forall (A : U) (x : A) -> Id A x x = \ A x C Cx -> Cx
defined refl : forall (A : U) (x : A) -> Id A x x = \ A x C Cx -> Cx

macro %refl = \ _ Cx -> Cx
macro %refl 
  = \ _ Cx -> Cx

define sym
  : forall (A : U) (x : A) (y : A) -> Id A x y -> Id A y x
  = \ A x y x=y -> x=y (\ z -> Id A z x) (refl A x)
defined sym
  : forall (A : U) (x : A) (y : A) -> Id A x y -> Id A y x
  = \ A x y x=y -> x=y (\ z -> Id A z x) (refl A x)

define trans
  : forall (A : U) (x : A) (y : A) (z : A) -> Id A x y -> Id A y z -> Id A x z
  = \ A x y z x=y y=z -> y=z (\ v -> Id A x v) x=y
defined trans
  : forall (A : U) (x : A) (y : A) (z : A) -> Id A x y -> Id A y z -> Id A x z
  = \ A x y z x=y y=z -> y=z (\ v -> Id A x v) x=y

end-of-file "examples/lib/leibniz.ptt"

type %refl : Id Nat (power5 two) (power5' two)
  : Id Nat (power5 two) (power5' two)

type %refl : Id (Nat -> Nat) power5 power5'
  : Id (Nat -> Nat) power5 power5'

end-of-file "examples/staging-power.ptt"

